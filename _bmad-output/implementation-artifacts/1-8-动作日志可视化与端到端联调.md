# Story 1.8: 动作日志可视化与端到端联调

Status: done

<!-- Note: Validation is optional. Run validate-create-story for quality check before dev-story. -->

## Story

As a 操作者,
I want 在右侧面板实时看到 Agent 每一步操作的详情——意图识别、Skill 加载、工具调用——以时间线形式逐步展开，点击可查看输入输出详情,
so that 能完整理解 Agent 的工作过程，亲眼验证"AI 在做事而非回答问题"。

## Acceptance Criteria

1. **Given** 用户发送消息后 **When** 右侧面板更新 **Then** 动作日志以 Timeline 形式从上到下逐条追加 ActionLogItem（FR16）

2. **Given** ActionLogItem 组件 **When** 动作执行中 **Then** 显示 Spin 旋转动画 + 浅蓝背景(#E6F4FF)

3. **Given** ActionLogItem 组件 **When** 动作成功完成 **Then** 显示绿色勾号 + 浅绿背景(#F6FFED)，可展开查看详情

4. **Given** ActionLogItem 组件 **When** 动作失败 **Then** 显示红色叉号 + 浅红背景(#FFF2F0)，自动展开显示错误信息

5. **Given** ActionLogItem 展开详情 **When** 点击查看 **Then** 显示该步骤的工具名称、输入参数和返回结果（FR17）

6. **Given** 新 ActionLogItem 追加 **When** 出现新动作 **Then** 带 fadeIn + slideUp 入场动画，面板自动滚动到底部

7. **Given** usePolling hook **When** Agent 执行中 **Then** 每 1 秒轮询 GET /api/status/{session_id}?after_index=N 获取增量动作（FR30, NFR2）

8. **Given** usePolling hook **When** Agent 状态变为 completed 或 error **Then** 自动停止轮询

9. **Given** 完整提前离店流程 **When** 从输入消息到流程完成 **Then** 动作日志依次展示：意图识别(FR18) → Skill 加载 → 查询订单 → 发送上游消息 → 等待上游回复 → 退款登记 → 发送下游回复 → 流程完成（FR19）

10. **Given** 流程完成 **When** 查看对话频道 **Then** 显示 Agent 最终回复消息（FR3）

## Tasks / Subtasks

- [x] Task 1: 创建 ActionLogItem 组件 (AC: #1, #2, #3, #4, #5, #6)
  - [x] 1.1 在 `src/components/ActionLogItem/ActionLogItem.tsx` 中创建动作日志条目组件
  - [x] 1.2 Props 设计：接收 `ActionLogEntry` 类型（index, action_type, title, summary, status, detail, timestamp）
  - [x] 1.3 状态图标渲染：running → Ant Design `Spin` 旋转动画；success → `CheckCircleFilled` 绿色(#52C41A)；error → `CloseCircleFilled` 红色(#FF4D4F)
  - [x] 1.4 背景色渲染：running → #E6F4FF 浅蓝；success → #F6FFED 浅绿；error → #FFF2F0 浅红
  - [x] 1.5 标题行：状态图标 + 动作标题(16px/500) + 时间戳(12px 灰色右对齐)
  - [x] 1.6 摘要行：summary 文字(14px/400)，一行显示
  - [x] 1.7 可展开详情区域：使用 Ant Design `Collapse` 组件，展示 detail 对象中的输入/输出参数
  - [x] 1.8 detail 渲染逻辑：将 detail dict 的 key-value 以 `Descriptions` 或简洁的 key: value 列表展示，非原始 JSON
  - [x] 1.9 error 状态自动展开详情（Collapse defaultActiveKey）
  - [x] 1.10 创建 `src/components/ActionLogItem/ActionLogItem.css`：入场动画 fadeIn + slideUp（CSS @keyframes）

- [x] Task 2: 创建 usePolling Hook (AC: #7, #8, #10)
  - [x] 2.1 在 `src/hooks/usePolling.ts` 中创建动作日志轮询 Hook
  - [x] 2.2 当 sessionStatus 为 'running' 时，每 1 秒调用 `api.pollStatus(sessionId, afterIndex)`
  - [x] 2.3 使用 useRef 跟踪 afterIndex（当前 actions 数组最大 index）
  - [x] 2.4 收到 new_actions 时 dispatch `ADD_ACTIONS` 追加到全局 state
  - [x] 2.5 收到 status 变化时 dispatch `SET_SESSION_STATUS`
  - [x] 2.6 收到 final_reply 时 dispatch `SET_FINAL_REPLY`
  - [x] 2.7 当 status 变为 'completed' 或 'error' 时，执行最后一次轮询后停止
  - [x] 2.8 使用 useRef 存储最新 state 引用避免 stale closure（参考 useMessagePolling 模式）
  - [x] 2.9 组件卸载时 useEffect cleanup 清理定时器

- [x] Task 3: 重写 ActionLogPanel 组件 (AC: #1, #6, #9)
  - [x] 3.1 修改 `src/views/DemoView/ActionLogPanel.tsx`：从 AppContext 获取 actions 数组
  - [x] 3.2 空状态保留：actions 为空时显示现有的欢迎提示（RobotOutlined 图标 + 文字）
  - [x] 3.3 有 actions 时：使用 Ant Design `Timeline` 组件渲染动作列表
  - [x] 3.4 Timeline 的每个 item 使用 ActionLogItem 组件渲染
  - [x] 3.5 自动滚动：使用 ref + scrollIntoView 在新 action 追加时滚动到底部
  - [x] 3.6 面板标题区域：显示"Agent 动作日志"标题(18px/600) + 当前 sessionStatus 状态标签(Tag)

- [x] Task 4: 集成 usePolling 到 DemoView (AC: #7, #8)
  - [x] 4.1 在 `DemoView.tsx` 中调用 `usePolling()` hook
  - [x] 4.2 确保 usePolling 和 useMessagePolling 同时工作、互不干扰
  - [x] 4.3 验证：发送消息后 sessionStatus 变为 'running' → 两个轮询 Hook 同时启动

- [x] Task 5: 端到端联调验证 (AC: #9, #10)
  - [x] 5.1 启动前后端，发送提前离店消息，验证动作日志完整展示 8 步流程
  - [x] 5.2 验证每步 ActionLogItem 状态转换：running → success（含 detail 可展开）
  - [x] 5.3 验证频道消息同步：上游群/下游群 Tab 红点提示正常
  - [x] 5.4 验证流程完成后：轮询停止、对话频道显示 Agent 最终回复
  - [x] 5.5 验证 TypeScript 编译零错误、Vite 构建成功、ESLint 零错误

## Dev Notes

### 核心设计：动作日志是 Demo 的灵魂，端到端联调是 Epic 1 的收官

本 Story 是 Epic 1（提前离店完整演示）的**最后一个 Story**，也是 Demo 的核心视觉体验。前 7 个 Story 已经搭建了完整的后端 Agent 引擎、REST API、前端框架和消息交互系统。本 Story 的使命是实现右侧动作日志面板的实时可视化，并通过端到端联调验证从"输入消息"到"流程完成"的完整体验闭环。

**本 Story 要做的：**
- ActionLogItem 自定义组件（三种状态：running/success/error，可展开详情）
- usePolling Hook（增量轮询动作日志 + 状态同步）
- ActionLogPanel 重写（空状态 → Timeline 渲染 → 自动滚动）
- DemoView 集成（usePolling + useMessagePolling 并行工作）
- 端到端联调验证（完整提前离店流程 8 步展示）

**本 Story 不做的：**
- 清空会话按钮功能（Story 2.2）
- 管理视图 Skill/工具列表（Story 3.1）
- 历史记录与回放（Story 3.2）
- 后端代码的任何修改（所有 API 已在 Story 1.5 实现完毕）

### 当前前端代码库状态（Story 1.7 完成后）

```
frontend/src/
├── App.tsx                    # Layout.Header 导航栏 + AppProvider + Routes
├── main.tsx                   # ConfigProvider（zhCN + #1677FF）
├── types/
│   └── index.ts              # 完整 TypeScript 类型（11 个类型/接口）
│                              # 包含 ActionLogEntry、StatusResponse、ActionType、ActionStatus 等
├── services/
│   └── api.ts                # 完整 API 层（10 个函数）
│                              # 包含 pollStatus(sessionId, afterIndex) ← 本 Story 核心依赖
├── context/
│   └── AppContext.tsx         # React Context（useReducer + 9 种 action）
│                              # 包含 ADD_ACTIONS、SET_SESSION_STATUS、SET_FINAL_REPLY
│                              # state.actions: ActionLogEntry[] ← 本 Story 核心消费
├── hooks/
│   ├── useMessagePolling.ts   # 消息频道轮询（Story 1.7 创建，正常工作）
│   └── [usePolling.ts]        # ← 本 Story 将创建（动作日志轮询）
├── components/
│   ├── ActionLogItem/
│   │   ├── .gitkeep           # ← 本 Story 将创建 ActionLogItem.tsx + .css
│   │   └── [ActionLogItem.tsx] # ← 新增
│   ├── ChatBubble/
│   │   ├── ChatBubble.tsx     # ✅ Story 1.7 创建
│   │   └── ChatBubble.css     # ✅ Story 1.7 创建
│   └── ChannelTab/.gitkeep
└── views/
    ├── DemoView/
    │   ├── DemoView.tsx       # 左右分屏布局 ← 本 Story 修改（集成 usePolling）
    │   ├── MessagePanel.tsx   # ✅ Story 1.7 完成（消息发送 + 频道切换 + 红点）
    │   └── ActionLogPanel.tsx # 空状态占位 ← 本 Story 重写
    ├── AdminView/AdminView.tsx # 管理视图占位
    └── HistoryView/HistoryView.tsx # 历史视图占位
```

### ActionLogItem 组件设计

```
成功状态（可展开）：                    执行中状态：
┌─────────────────────────────────┐   ┌─────────────────────────────────┐
│ ✓ 调用工具：查询订单    14:30:01│   │ ◎ 正在退款登记...      14:30:05│
│   查询订单号 HT20260301001     │   │   处理退款请求中               │
│   ▶ 查看详情                   │   │   （不可展开，无详情）          │
│   ┌───────────────────────────┐│   └─────────────────────────────────┘
│   │ 输入：                    ││
│   │   订单号: HT20260301001   ││   失败状态（自动展开）：
│   │ 输出：                    ││   ┌─────────────────────────────────┐
│   │   供应商订单号: SUP-88901 ││   │ ✕ 调用工具：查询订单  14:30:01 │
│   └───────────────────────────┘│   │   查询失败                     │
└─────────────────────────────────┘   │   ┌───────────────────────────┐│
                                      │   │ 错误: 订单不存在          ││
                                      │   └───────────────────────────┘│
                                      └─────────────────────────────────┘
```

**Props 设计：**
```typescript
interface ActionLogItemProps {
  action: ActionLogEntry;  // 直接传入 ActionLogEntry 类型
}
```

**从 types/index.ts 已有的 ActionLogEntry：**
```typescript
interface ActionLogEntry {
  index: number;
  action_type: ActionType;  // 'intent_recognition' | 'skill_loaded' | 'tool_call' | 'waiting' | 'message_sent' | 'completed'
  title: string;
  summary: string;
  status: ActionStatus;     // 'running' | 'success' | 'error'
  detail: Record<string, unknown> | null;
  timestamp: string;
}
```

**action_type 对应图标建议（非状态图标，可选增强）：**

| action_type | 含义 | 可选辅助图标 |
|-------------|------|-------------|
| intent_recognition | 意图识别 | BulbOutlined |
| skill_loaded | Skill 加载 | AppstoreOutlined |
| tool_call | 工具调用 | ToolOutlined |
| waiting | 等待回复 | HourglassOutlined |
| message_sent | 消息发送 | SendOutlined |
| completed | 流程完成 | CheckCircleOutlined |

**注意：** 状态图标（Spin/✓/✕）优先于 action_type 图标。Spin 用于 running，CheckCircleFilled 用于 success，CloseCircleFilled 用于 error。action_type 图标是可选的视觉增强，不是必需的。

### 状态色彩系统速查

| 状态 | 图标 | 图标色 | 背景色 | 来源 |
|------|------|--------|--------|------|
| running（执行中） | Spin 动画 | #1677FF 蓝 | #E6F4FF 浅蓝 | UX 设计文档 |
| success（成功） | CheckCircleFilled | #52C41A 绿 | #F6FFED 浅绿 | UX 设计文档 |
| error（失败） | CloseCircleFilled | #FF4D4F 红 | #FFF2F0 浅红 | UX 设计文档 |
| waiting（等待） | HourglassOutlined | #FAAD14 橙 | #FFFBE6 浅黄 | UX 设计文档 |

**注意 waiting 状态：** 后端 `waiting` action_type 的 status 仍然是 `running`（因为 ActionStatus 只有三种值）。可以通过 `action_type === 'waiting'` 来特殊处理，使用橙色而非蓝色。

### usePolling Hook 设计

```typescript
// src/hooks/usePolling.ts
import { useEffect, useRef, useCallback } from 'react';
import { useAppContext } from '../context/AppContext';
import { pollStatus } from '../services/api';

const POLL_INTERVAL = 1000;

export function usePolling() {
  const { state, dispatch } = useAppContext();
  const stateRef = useRef(state);

  useEffect(() => {
    stateRef.current = state;
  }, [state]);

  const fetchStatus = useCallback(async () => {
    const current = stateRef.current;
    if (!current.sessionId) return;

    try {
      // 增量轮询：传入当前 actions 中最大的 index
      const afterIndex = current.actions.length > 0
        ? current.actions[current.actions.length - 1].index
        : undefined;

      const response = await pollStatus(current.sessionId, afterIndex);

      // 追加新 actions
      const newActions = response.new_actions || [];
      if (newActions.length > 0) {
        dispatch({ type: 'ADD_ACTIONS', actions: newActions });
      }

      // 同步会话状态
      if (response.status !== current.sessionStatus) {
        dispatch({ type: 'SET_SESSION_STATUS', status: response.status });
      }

      // 同步最终回复
      if (response.final_reply && !current.finalReply) {
        dispatch({ type: 'SET_FINAL_REPLY', reply: response.final_reply });
      }
    } catch {
      // 轮询失败静默忽略，下次重试
    }
  }, [dispatch]);

  useEffect(() => {
    if (state.sessionStatus !== 'running') return;

    fetchStatus(); // 立即执行一次
    const timer = setInterval(fetchStatus, POLL_INTERVAL);
    return () => clearInterval(timer);
  }, [state.sessionStatus, fetchStatus]);
}
```

**关键设计决策：**
- 使用 `useRef` 存储最新 state，避免 stale closure 问题（与 useMessagePolling 相同模式）
- `afterIndex` 使用 actions 数组最后一个元素的 index，而非 actions.length
- 首次轮询不传 afterIndex（获取完整状态），之后传 afterIndex（增量获取）
- 轮询只在 `sessionStatus === 'running'` 时持续，completed/error 后自动停止

### ActionLogPanel 重写设计

**从 AppContext 获取数据：**
```typescript
const { state } = useAppContext();
const { actions, sessionStatus } = state;
```

**条件渲染逻辑：**
```
if (actions.length === 0) {
  → 显示现有空状态欢迎提示（保留 RobotOutlined 图标 + 文字）
} else {
  → 顶部：面板标题"Agent 动作日志" + 状态 Tag
  → 主体：Timeline 组件，items = actions.map(action => ActionLogItem)
  → 自动滚动到底部
}
```

**Ant Design Timeline 使用（v6）：**
```typescript
import { Timeline } from 'antd';

// v6 Timeline 使用 items 属性
<Timeline
  items={actions.map(action => ({
    dot: <StatusDot status={action.status} actionType={action.action_type} />,
    children: <ActionLogItem action={action} />,
  }))}
/>
```

**注意：** Ant Design v6 的 Timeline 组件推荐使用 `items` 属性（不使用 Timeline.Item 子组件），与 Tabs 使用 `items` 的模式一致。

**自动滚动实现：**
```typescript
const endRef = useRef<HTMLDivElement>(null);
useEffect(() => {
  endRef.current?.scrollIntoView({ behavior: 'smooth' });
}, [actions.length]);

// 在 Timeline 下方放置锚点
<div ref={endRef} />
```

### detail 详情渲染策略

后端 ActionLogEntry 的 `detail` 字段是一个任意结构的 dict，不同 action_type 返回不同的 detail 内容：

| action_type | detail 结构示例 |
|-------------|----------------|
| intent_recognition | `{ "intent": "提前离店", "confidence": 0.95 }` |
| skill_loaded | `{ "skill_id": "early_checkout", "skill_name": "提前离店" }` |
| tool_call | `{ "tool_name": "查询订单", "input": { "order_no": "HT..." }, "output": { "supplier_no": "SUP..." } }` |
| waiting | `{ "waiting_for": "上游回复" }` |
| message_sent | `{ "channel": "downstream", "content": "退款已完成..." }` |
| completed | `{ "final_reply": "已为您完成..." }` |

**渲染策略：通用 key-value 展示，非 JSON dump**

```typescript
function renderDetail(detail: Record<string, unknown>) {
  return (
    <div style={{ padding: '8px 12px', background: '#fafafa', borderRadius: 4, fontSize: 13 }}>
      {Object.entries(detail).map(([key, value]) => (
        <div key={key} style={{ marginBottom: 4 }}>
          <span style={{ color: '#8c8c8c', marginRight: 8 }}>{formatKey(key)}:</span>
          <span>{formatValue(value)}</span>
        </div>
      ))}
    </div>
  );
}

// key 翻译映射（业务语言优先）
function formatKey(key: string): string {
  const keyMap: Record<string, string> = {
    intent: '识别意图',
    confidence: '置信度',
    skill_id: 'Skill ID',
    skill_name: 'Skill 名称',
    tool_name: '工具名称',
    input: '输入',
    output: '输出',
    channel: '目标频道',
    content: '消息内容',
    waiting_for: '等待',
    final_reply: '最终回复',
    order_no: '订单号',
    supplier_no: '供应商订单号',
    error: '错误',
    message: '消息',
  };
  return keyMap[key] || key;
}
```

**重要：** 不要直接 `JSON.stringify(detail)` 展示原始 JSON。UX 设计要求"业务语言优先"，将技术字段翻译成用户可理解的中文标签。

### 入场动画 CSS

```css
/* src/components/ActionLogItem/ActionLogItem.css */

.action-log-item {
  animation: fadeInSlideUp 0.3s ease-out;
}

@keyframes fadeInSlideUp {
  from {
    opacity: 0;
    transform: translateY(12px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}
```

### 后端 API 端点速查（与本 Story 的交互）

| 端点 | 方法 | 本 Story 用途 |
|------|------|-------------|
| `/api/status/{session_id}` | GET | usePolling 轮询获取增量 actions |
| `/api/status/{session_id}?after_index=N` | GET | 增量模式：仅返回 index > N 的 new_actions |
| `/api/chat` | POST | 已在 Story 1.7 集成（MessagePanel.tsx 调用） |
| `/api/messages/{channel}` | GET | 已在 Story 1.7 集成（useMessagePolling.ts 调用） |

**StatusResponse 结构（from types/index.ts）：**
```typescript
interface StatusResponse {
  session_id: string;
  status: SessionStatus;          // 'idle' | 'running' | 'completed' | 'error'
  new_actions?: ActionLogEntry[]; // 增量模式返回
  actions?: ActionLogEntry[];     // 全量模式返回（不传 after_index）
  unread_channels: string[];
  final_reply: string | null;
}
```

**关键：** `new_actions` 和 `actions` 是互斥的。传 `after_index` 时返回 `new_actions`，不传时返回 `actions`。usePolling 应优先使用增量模式。

### AppContext 已有的 Action 类型

本 Story 使用的 action（全部已存在，无需修改 AppContext）：
- `ADD_ACTIONS` — 追加新 ActionLogEntry 到 state.actions 数组
- `SET_SESSION_STATUS` — 更新会话状态（running → completed/error）
- `SET_FINAL_REPLY` — 设置 Agent 最终回复文字

**ADD_ACTIONS 的 reducer 行为：**
```typescript
case 'ADD_ACTIONS':
  return { ...state, actions: [...state.actions, ...action.actions] };
```
这是追加模式（不替换），与增量轮询完美配合。

### 两个轮询 Hook 的分工

| Hook | 文件 | 轮询端点 | 用途 | 触发条件 | Story |
|------|------|---------|------|---------|-------|
| useMessagePolling | hooks/useMessagePolling.ts | GET /api/messages/{channel} | 三频道消息同步 + 未读标记 | sessionStatus='running' 或 'completed' | 1.7 ✅ |
| usePolling | hooks/usePolling.ts | GET /api/status/{session_id} | 动作日志增量获取 + 状态同步 | sessionStatus='running' | 1.8 ← 本 Story |

**两个 Hook 并行工作，各自独立轮询不同的 API 端点。** 在 DemoView.tsx 中同时调用两个 Hook。

### 已安装依赖（package.json）

- react: ^19.2.0, react-dom: ^19.2.0
- antd: ^6.3.1（Ant Design v6）
- @ant-design/icons: ^6.1.0
- react-router-dom: ^7.13.1
- typescript: ~5.9.3, vite: ^7.3.1

**无需安装新依赖。** 所有需要的组件（Timeline、Collapse、Spin、Tag、Badge）都在 antd 包中。所有需要的图标（CheckCircleFilled、CloseCircleFilled、BulbOutlined 等）都在 @ant-design/icons 包中。

### 文件组织

本 Story 创建/修改的文件：

```
frontend/src/
├── components/
│   └── ActionLogItem/
│       ├── ActionLogItem.tsx     # 新增：动作日志条目组件
│       └── ActionLogItem.css     # 新增：入场动画样式
├── hooks/
│   └── usePolling.ts             # 新增：动作日志轮询 Hook
└── views/
    └── DemoView/
        ├── DemoView.tsx          # 修改：集成 usePolling Hook
        └── ActionLogPanel.tsx    # 重写：空状态 → Timeline 动作日志
```

**禁止创建/修改的文件：**
- context/AppContext.tsx — 已完整，无需修改
- services/api.ts — 已完整，无需修改
- types/index.ts — 已完整，无需修改
- hooks/useMessagePolling.ts — Story 1.7 创建，不要修改
- views/DemoView/MessagePanel.tsx — Story 1.7 完成，不要修改
- backend/ 目录下的任何文件 — 所有 API 已在 Story 1.5 实现

### 样式规范

| 元素 | 尺寸/色值 | 来源 |
|------|---------|------|
| 面板标题 | 18px/600 | UX 设计文档 区域标题 |
| 步骤标题 | 16px/500 | UX 设计文档 步骤标题 |
| 正文 | 14px/400 | UX 设计文档 正文 |
| 辅助文字 | 12px/400 灰色(#8C8C8C) | UX 设计文档 辅助文字 |
| 执行中背景 | #E6F4FF | UX 设计文档 |
| 成功背景 | #F6FFED | UX 设计文档 |
| 失败背景 | #FFF2F0 | UX 设计文档 |
| 面板内边距 | 24px | UX 设计文档 8px 倍数体系 |
| 行高 | 1.5 | UX 设计文档 中文阅读 |

### 命名规范

| 场景 | 规则 | 示例 |
|------|------|------|
| 组件文件名 | PascalCase.tsx | `ActionLogItem.tsx` |
| Hook 文件名 | camelCase.ts | `usePolling.ts` |
| CSS 文件名 | PascalCase.css | `ActionLogItem.css` |
| 组件 Props | PascalCase + Props 后缀 | `ActionLogItemProps` |
| 事件处理函数 | handle + 动作 | `handleExpand` |
| 状态变量 | camelCase | `isExpanded` |
| TypeScript 接口 JSON 字段 | snake_case | `action_type`, `final_reply` |

### 前一个 Story (1.7) 关键成果与教训

**成果：**
- ChatBubble 组件、消息发送功能、三频道消息显示、消息轮询 Hook
- 所有 AppContext action 已验证可用
- API 层所有函数已验证可用
- TypeScript 零错误编译

**Code Review 修复项（模式参考）：**
- [H1] 乐观更新失败回滚 — sendMessage 失败时恢复 prevMessages
- [H2] 乐观消息 sender 改为 `"user"`（与后端一致）
- [M1] isUserMessage 简化为仅匹配 `"user"`（后端唯一用户 sender 值）
- [M2] useMessagePolling stateRef 同步 useEffect 添加 `[state]` 依赖 — **usePolling 必须遵循同样模式**
- [M3] 移除未使用 props — 保持接口精简

**关键代码模式（必须遵循）：**
- 使用 `useAppContext()` hook 获取 state 和 dispatch
- Ant Design v6 使用 `items` 属性（Timeline、Tabs 等），不使用子组件模式
- 所有 API 调用通过 `services/api.ts` 的封装函数
- 使用 `useRef` + `useEffect([state])` 模式避免 stale closure
- 使用 `useCallback` 包裹异步函数以满足 ESLint react-hooks 规则
- 内联样式为主（与现有代码风格一致），组件级样式用 CSS 文件

### 架构边界提醒

**本 Story 的职责边界：**
- 实现动作日志的实时可视化渲染
- 实现动作日志的增量轮询
- 实现端到端联调验证

**与后续 Story 的接口：**
- Story 2.2 将实现清空会话功能（dispatch RESET），重置所有状态包括 actions
- Story 2.1 将增加新的 Skill，动作日志面板无需修改（只需渲染 ActionLogEntry 数据）
- Story 3.2 将实现历史记录回放，可能复用 ActionLogItem 组件

**关键依赖（已就绪）：**
- Story 1.7 的 sendMessage 设置 sessionStatus='running' → 触发 usePolling
- Story 1.5 的 `/api/status/{session_id}` 返回增量 actions → usePolling 消费
- Story 1.4 的 Agent 引擎产生 ActionLogEntry → 通过 Store → API → 前端

### Git 智能

最近 commits：
```
5ba5553 Complete Story 1.7: 消息交互与三频道系统
16780e5 Complete Story 1.6: 前端框架与演示视图布局
28f8073 Complete Story 1.5: 后端 REST API 与通信层
dc7dcff Complete Story 1.4: Agent 引擎与提前离店 Skill
4a4106c Complete Story 1.3: 模拟工具与模拟数据
2104e42 Complete Story 1.2: 数据模型与内存存储
dca5dfc Complete Story 1.1: 项目初始化与开发环境搭建
```

代码模式观察：
- 每个 Story 完成后单独 commit，commit message 格式："Complete Story X.Y: 标题"
- Story 1.7 创建/修改了 4 个前端文件（2 新增 + 1 重写 + 1 新增 Hook）
- TypeScript 编译零错误、Vite 构建成功、ESLint 零错误是完成标准
- 后端 151 测试全部通过零回归

### Project Structure Notes

- 本 Story 遵循架构文档定义的前端目录结构
- ActionLogItem 放在 `components/ActionLogItem/` 目录下（遵循已有目录结构，替换 .gitkeep）
- usePolling 放在 `hooks/` 目录下（与 useMessagePolling 平级）
- ActionLogPanel 在 `views/DemoView/` 目录下重写（就地修改现有文件）
- DemoView 在同目录下修改（仅添加 usePolling Hook 调用）

### References

- [Source: _bmad-output/planning-artifacts/epics.md#Story 1.8] — 验收标准（10 条 AC）
- [Source: _bmad-output/planning-artifacts/architecture.md#API & Communication Patterns] — REST 端点定义、轮询机制（after_index 增量返回）
- [Source: _bmad-output/planning-artifacts/architecture.md#Frontend Architecture] — 组件组织、Hooks 设计、状态管理
- [Source: _bmad-output/planning-artifacts/architecture.md#Communication Patterns] — action_type 枚举、status 枚举、StatusResponse 结构
- [Source: _bmad-output/planning-artifacts/architecture.md#Naming Patterns] — TypeScript camelCase、组件 PascalCase
- [Source: _bmad-output/planning-artifacts/ux-design-specification.md#Component Strategy] — ActionLogItem 组件设计（三种状态、可展开详情）
- [Source: _bmad-output/planning-artifacts/ux-design-specification.md#Design Direction Decision] — 动作日志而非预设流程图、追加模式、入场动画
- [Source: _bmad-output/planning-artifacts/ux-design-specification.md#Visual Design Foundation] — 色彩系统（状态色）、字号层级
- [Source: _bmad-output/planning-artifacts/ux-design-specification.md#UX Consistency Patterns] — 反馈模式、空状态设计
- [Source: _bmad-output/implementation-artifacts/1-7-消息交互与三频道系统.md] — useRef+useCallback 模式、Code Review 修复经验
- [Source: backend/app/routers/status.py] — 轮询 API 实现（增量/全量模式）
- [Source: backend/app/schemas/models.py] — ActionLogEntry 模型定义
- [Source: backend/app/agent/engine.py] — Agent 动作日志生成模式（running→success lifecycle）

## Dev Agent Record

### Agent Model Used

Claude Opus 4.6

### Debug Log References

- ESLint: 修复后无错误
- MessagePanel 已在内部调用 useMessagePolling()，DemoView 中不可重复调用，否则会产生双重轮询。初始代码已修正。

### Code Review Fixes

- [H1] usePolling 首次轮询丢弃全量 actions 响应：`response.new_actions || []` 改为 `response.new_actions || response.actions || []`，修复全量模式（无 after_index 参数）下 actions 字段被忽略导致动作日志永远为空的致命 bug
- [M1] 移除 ActionLogItem 内部重复状态图标：Timeline dot 已渲染状态图标，ActionLogItem 不再额外渲染，避免每个 action 显示两个一模一样的图标
- [M2] renderDetail 添加数组类型安全检查：`Array.isArray(value)` 排除数组进入 object 分支，数组值使用逗号拼接展示
- [L1] 清理 `frontend/src/components/ActionLogItem/.gitkeep` 占位文件

### Completion Notes List

- Task 1: ActionLogItem 组件完成，支持三种状态（running/success/error）对应不同图标和背景色，waiting action_type 特殊处理使用橙色。Collapse ghost 模式展开详情，detail 使用 key 翻译映射渲染业务语言，error 状态自动展开。CSS fadeInSlideUp 入场动画 0.3s。
- Task 2: usePolling hook 完成，遵循 useMessagePolling 相同模式（useRef + useEffect[state] + useCallback），sessionStatus='running' 时 1 秒间隔增量轮询 pollStatus(sessionId, afterIndex)，同步 actions/status/finalReply 三种状态。
- Task 3: ActionLogPanel 重写完成，空状态保留 RobotOutlined 欢迎提示，有 actions 时使用 Timeline items 渲染 + ActionLogItem 组件，顶部标题区 "Agent 动作日志" + 状态 Tag（idle/running/completed/error 四色），endRef scrollIntoView 自动滚动。
- Task 4: DemoView 集成 usePolling hook，useMessagePolling 保持在 MessagePanel 内部调用（避免双重轮询），两个 Hook 各自独立轮询不同端点。
- Task 5: TypeScript 零错误、Vite build 成功（2.46s）、ESLint 零错误、后端 151 测试零回归。

### Change Log

- 2026-02-27: Story 1.8 实现完成 — 动作日志可视化与端到端联调（ActionLogItem 组件 + usePolling Hook + ActionLogPanel Timeline 渲染 + DemoView 集成）
- 2026-02-27: Code Review 修复 — 4 项修复（H1 全量响应丢弃 + M1 重复图标 + M2 数组安全 + L1 gitkeep 清理）

### File List

- frontend/src/components/ActionLogItem/ActionLogItem.tsx (新增)
- frontend/src/components/ActionLogItem/ActionLogItem.css (新增)
- frontend/src/hooks/usePolling.ts (新增)
- frontend/src/views/DemoView/ActionLogPanel.tsx (重写)
- frontend/src/views/DemoView/DemoView.tsx (修改)
