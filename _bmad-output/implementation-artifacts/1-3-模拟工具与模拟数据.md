# Story 1.3: 模拟工具与模拟数据

Status: done

<!-- Note: Validation is optional. Run validate-create-story for quality check before dev-story. -->

## Story

As a 开发者,
I want 实现工具基类接口、3 个模拟工具（订单查询、消息发送、退款登记）以及硬编码模拟数据和上游自动回复逻辑,
so that Agent 引擎可以调用这些工具执行模拟业务操作，模拟完整的提前离店流程。

## Acceptance Criteria

1. **Given** agent/tools/base.py **When** 定义工具基类 **Then** 包含统一接口：name(str)、description(str)、execute(input) → output，所有工具继承此基类（NFR5）

2. **Given** agent/tools/order_query.py **When** 调用执行并传入有效订单号 "HT20260301001" **Then** 返回对应的供应商订单号 "SUP-88901"（FR23）

3. **Given** agent/tools/order_query.py **When** 调用执行并传入无效订单号 **Then** 返回合理的错误信息"订单不存在"（FR26）

4. **Given** agent/tools/message_send.py **When** 调用执行并指定目标频道（downstream/upstream）和消息内容 **Then** 消息被添加到对应频道的内存存储中（FR20, FR21）

5. **Given** agent/tools/refund.py **When** 调用执行并传入订单信息 **Then** 返回退款登记成功结果（FR24）

6. **Given** mock/data.py **When** 查看模拟数据 **Then** 包含至少 3 条硬编码订单记录（订单号 → 供应商订单号映射）

7. **Given** mock/upstream.py **When** 上游收到消息后 **Then** 自动生成模拟上游回复"已处理完成"并添加到 upstream 频道（FR22）

8. **Given** agent/tools/__init__.py **When** 导入工具注册表 **Then** 自动发现并注册所有工具，提供按名称查找工具的能力（NFR5）

## Tasks / Subtasks

- [x] Task 1: 定义工具基类接口 (AC: #1)
  - [x] 1.1 在 `backend/app/agent/tools/base.py` 中定义 `BaseTool` 抽象基类
  - [x] 1.2 定义抽象属性：`name` (str)、`description` (str)
  - [x] 1.3 定义抽象方法：`execute(self, **kwargs) -> dict`
  - [x] 1.4 定义 `get_definition(self) -> ToolDefinition` 方法，返回工具元信息

- [x] Task 2: 创建模拟数据模块 (AC: #6)
  - [x] 2.1 在 `backend/app/mock/data.py` 中定义硬编码订单数据（≥3 条记录）
  - [x] 2.2 包含订单号 → 供应商订单号映射（如 HT20260301001 → SUP-88901）
  - [x] 2.3 包含订单详情信息（客户名、入住日期、退房日期、房型等）

- [x] Task 3: 实现订单查询工具 (AC: #2, #3)
  - [x] 3.1 在 `backend/app/agent/tools/order_query.py` 中创建 `OrderQueryTool` 继承 `BaseTool`
  - [x] 3.2 实现 `execute`：从 `mock/data.py` 查询，有效订单返回供应商订单号
  - [x] 3.3 无效订单返回错误信息 `{"error": true, "error_type": "ORDER_NOT_FOUND", "message": "订单不存在"}`

- [x] Task 4: 实现消息发送工具 (AC: #4)
  - [x] 4.1 在 `backend/app/agent/tools/message_send.py` 中创建 `MessageSendTool` 继承 `BaseTool`
  - [x] 4.2 实现 `execute`：接收 channel、content 参数，调用 `store.add_message` 写入消息
  - [x] 4.3 写入后调用 `store.mark_channel_unread` 标记频道未读

- [x] Task 5: 实现退款登记工具 (AC: #5)
  - [x] 5.1 在 `backend/app/agent/tools/refund.py` 中创建 `RefundTool` 继承 `BaseTool`
  - [x] 5.2 实现 `execute`：接收订单号参数，返回退款成功结果

- [x] Task 6: 实现上游自动回复模拟 (AC: #7)
  - [x] 6.1 在 `backend/app/mock/upstream.py` 中创建 `simulate_upstream_reply` 函数
  - [x] 6.2 函数逻辑：在 upstream 频道添加一条供应商回复消息"已处理完成，可以办理退款"
  - [x] 6.3 调用 `store.mark_channel_unread("upstream")` 标记未读

- [x] Task 7: 实现工具注册表 (AC: #8)
  - [x] 7.1 在 `backend/app/agent/tools/__init__.py` 中实现工具自动发现和注册
  - [x] 7.2 使用 `__init_subclass__` 模式自动注册继承 `BaseTool` 的工具类
  - [x] 7.3 提供 `get_tool(name: str) -> BaseTool` 按名称查找
  - [x] 7.4 提供 `get_all_tools() -> list[BaseTool]` 获取全部工具
  - [x] 7.5 提供 `get_tool_definitions() -> list[ToolDefinition]` 获取全部工具元信息

- [x] Task 8: 编写单元测试 (AC: #1-#8)
  - [x] 8.1 在 `backend/tests/test_tools.py` 中测试 BaseTool 抽象基类不可直接实例化
  - [x] 8.2 测试 OrderQueryTool：有效订单返回正确供应商订单号
  - [x] 8.3 测试 OrderQueryTool：无效订单返回错误信息
  - [x] 8.4 测试 MessageSendTool：消息写入对应频道并标记未读
  - [x] 8.5 测试 RefundTool：返回退款成功结果
  - [x] 8.6 测试 mock/data.py 数据结构完整性（≥3 条记录）
  - [x] 8.7 测试 mock/upstream.py：自动回复写入 upstream 频道
  - [x] 8.8 测试工具注册表：自动发现所有工具、按名称查找、获取工具定义

## Dev Notes

### 技术栈版本（已验证）

| 库 | 版本 | 说明 |
|---|---|---|
| Python | 3.12+ | 支持 `str | None` 语法、ABC |
| Pydantic | 2.12.5 | Story 1.2 已安装验证 |
| FastAPI | 0.133.1 | 已安装验证 |
| pytest | dev 依赖 | Story 1.2 已安装 |

### 工具基类设计规范

使用 Python ABC（Abstract Base Class）定义工具接口，**不使用 Protocol**。理由：架构文档明确要求"所有工具继承此基类"，ABC 在实例化时即时验证子类是否实现了全部抽象方法，适合这个严格的继承关系。

```python
# ✅ 正确 — 使用 ABC + abstractmethod
from abc import ABC, abstractmethod
from app.schemas.models import ToolDefinition

class BaseTool(ABC):
    """工具基类接口。所有模拟工具必须继承此类。"""

    @property
    @abstractmethod
    def name(self) -> str:
        """工具名称标识符（snake_case）。"""
        ...

    @property
    @abstractmethod
    def description(self) -> str:
        """工具功能说明。"""
        ...

    @abstractmethod
    def execute(self, **kwargs) -> dict:
        """执行工具操作。返回结果字典。"""
        ...

    def get_definition(self) -> ToolDefinition:
        """返回工具元信息，供管理 API 使用。"""
        return ToolDefinition(
            name=self.name,
            description=self.description,
            parameters=self._get_parameters(),
        )

    @abstractmethod
    def _get_parameters(self) -> dict:
        """返回参数描述字典。"""
        ...
```

```python
# ❌ 禁止 — 不使用 Protocol（架构要求显式继承）
from typing import Protocol
class ToolInterface(Protocol):  # 不要这样做
    ...
```

### 工具注册表模式

使用 `__init_subclass__` 自动注册 + `pkgutil.iter_modules` 自动发现：

```python
# agent/tools/__init__.py — 工具注册表
import importlib
import pkgutil
from pathlib import Path

# 注册表由 BaseTool.__init_subclass__ 自动填充
_tool_registry: dict[str, type["BaseTool"]] = {}

class BaseTool(ABC):
    def __init_subclass__(cls, **kwargs):
        super().__init_subclass__(**kwargs)
        # 只注册非抽象的具体工具类
        if not getattr(cls, '__abstractmethods__', None):
            instance = cls()
            _tool_registry[instance.name] = instance

# 自动导入当前目录下所有模块，触发 __init_subclass__
_package_dir = Path(__file__).parent
for _, module_name, _ in pkgutil.iter_modules([str(_package_dir)]):
    if module_name != "base":
        importlib.import_module(f".{module_name}", __package__)
```

**重要决策：** `BaseTool` 定义在 `base.py` 中，注册表逻辑在 `__init__.py` 中。`__init__.py` 导入 `BaseTool` 并添加 `__init_subclass__` 逻辑后，再动态导入其他工具模块触发注册。

**更简洁的方案：** 将 `__init_subclass__` 直接放在 `BaseTool` 类中（`base.py`），`__init__.py` 只负责导入和暴露 API。这样更符合单一职责。

### 模拟数据规格

```python
# mock/data.py — 硬编码订单数据
MOCK_ORDERS = {
    "HT20260301001": {
        "order_id": "HT20260301001",
        "supplier_order_id": "SUP-88901",
        "guest_name": "张三",
        "hotel_name": "杭州西湖大酒店",
        "check_in": "2026-03-01",
        "check_out": "2026-03-05",
        "room_type": "大床房",
        "status": "confirmed",
    },
    "HT20260301002": {
        "order_id": "HT20260301002",
        "supplier_order_id": "SUP-88902",
        "guest_name": "李四",
        "hotel_name": "上海外滩酒店",
        "check_in": "2026-03-10",
        "check_out": "2026-03-12",
        "room_type": "双床房",
        "status": "confirmed",
    },
    "HT20260301003": {
        "order_id": "HT20260301003",
        "supplier_order_id": "SUP-88903",
        "guest_name": "王五",
        "hotel_name": "北京国贸大饭店",
        "check_in": "2026-03-15",
        "check_out": "2026-03-18",
        "room_type": "套房",
        "status": "confirmed",
    },
}
```

**关键约束：**
- AC #2 指定 "HT20260301001" → "SUP-88901"，**必须**使用这对映射
- AC #6 要求 ≥3 条记录
- 订单号 "HT20260301002" 将被 Story 2.1 的订单取消场景使用（预留）

### 工具执行返回值格式

所有工具 `execute` 方法返回 `dict`，格式统一：

**成功：**
```python
{
    "success": True,
    "data": { ... }  # 具体结果
}
```

**失败：**
```python
{
    "error": True,
    "error_type": "ORDER_NOT_FOUND",
    "message": "订单不存在"
}
```

与架构文档的统一错误响应格式保持一致。

### 消息发送工具与 MemoryStore 交互

`MessageSendTool.execute` 需要访问 `store` 单例：

```python
from app.store.memory import store

class MessageSendTool(BaseTool):
    def execute(self, *, channel: str, content: str, sender: str = "agent") -> dict:
        msg = store.add_message(
            channel=Channel(channel),
            sender=sender,
            content=content,
        )
        store.mark_channel_unread(channel)
        return {"success": True, "data": {"channel": channel, "content": content}}
```

**关键：** 工具直接导入并使用 `store` 单例，这符合架构文档"Store 是唯一的状态读写点"的要求。

### 上游自动回复模拟

`mock/upstream.py` 的 `simulate_upstream_reply` 函数：
- 接收参数：供应商订单号（用于回复内容中引用）
- 向 upstream 频道添加一条消息，sender 为 "supplier"
- 标记 upstream 频道为未读
- 返回回复消息内容
- 此函数将被 Story 1.4 的 Agent 引擎在"等待上游回复"步骤中调用

### 前一个 Story (1.2) 关键信息

- **已完成并通过 Code Review**
- `schemas/models.py`：全部 4 个枚举（ActionType、ActionStatus、SessionStatus、Channel）+ 6 个 Pydantic 模型
- `store/memory.py`：MemoryStore 单例，含完整的 CRUD 方法
- `store` 单例通过 `from app.store.memory import store` 导入使用
- 所有 datetime 使用 `datetime.now(UTC)` 生成 UTC 时间戳
- 无活跃会话时操作抛出 `ValueError`
- 54 个单元测试全部通过
- pytest 已作为 dev 依赖安装

### Git 智能

- 共 3 个 commit，最新为 Story 1.1 完成
- Story 1.2 的代码已写入但尚未 commit（在工作目录中）
- `backend/app/agent/tools/__init__.py` 已存在（空文件）
- `backend/app/mock/__init__.py` 已存在（空文件）

### Project Structure Notes

本 Story 涉及的文件：

```
backend/app/
├── agent/
│   └── tools/
│       ├── __init__.py           # 修改：工具注册表（自动发现+注册）
│       ├── base.py               # 新增：工具抽象基类
│       ├── order_query.py        # 新增：订单查询工具
│       ├── message_send.py       # 新增：消息发送工具
│       └── refund.py             # 新增：退款登记工具
├── mock/
│   ├── __init__.py               # 已存在（保持空）
│   ├── data.py                   # 新增：硬编码模拟数据
│   └── upstream.py               # 新增：上游自动回复模拟
└── schemas/
    └── models.py                 # 只读引用（ToolDefinition、Channel）

backend/tests/
├── test_tools.py                 # 新增：工具单元测试
└── test_mock.py                  # 新增：模拟层单元测试（可选，也可合入 test_tools.py）
```

### 架构边界提醒

**只做：**
- 定义工具基类接口和 3 个具体工具实现
- 创建模拟数据（硬编码订单）
- 实现上游自动回复模拟
- 实现工具注册表（自动发现+按名称查找）
- 编写单元测试

**禁止：**
- 创建订单取消工具 order_cancel.py（Story 2.1 负责）
- 实现 Agent 引擎或 LangGraph 状态图（Story 1.4 负责）
- 创建 Skill 文件 .md（Story 1.4 负责）
- 创建任何 API 路由（Story 1.5 负责）
- 修改 main.py
- 创建前端文件

### 命名规范

| 场景 | 规则 | 示例 |
|------|------|------|
| 工具类名 | PascalCase | `OrderQueryTool`, `MessageSendTool`, `RefundTool` |
| 工具标识符 (name 属性) | snake_case | `order_query`, `message_send`, `refund` |
| Python 文件名 | snake_case | `order_query.py`, `message_send.py` |
| 模拟数据变量 | UPPER_SNAKE_CASE | `MOCK_ORDERS` |
| 函数名 | snake_case | `simulate_upstream_reply`, `get_tool` |

### References

- [Source: _bmad-output/planning-artifacts/architecture.md#Structure Patterns] — 后端目录结构，tools/ 和 mock/ 位置
- [Source: _bmad-output/planning-artifacts/architecture.md#Implementation Patterns] — 命名规范（Python snake_case）
- [Source: _bmad-output/planning-artifacts/architecture.md#Architectural Boundaries] — 后端分层边界，Tools 通过基类接口访问 Mock 层
- [Source: _bmad-output/planning-artifacts/architecture.md#Core Architectural Decisions] — 工具基类接口定义（base.py）
- [Source: _bmad-output/planning-artifacts/epics.md#Story 1.3] — 验收标准 8 条
- [Source: _bmad-output/planning-artifacts/prd.md#模拟系统] — FR20-FR26 模拟系统需求
- [Source: _bmad-output/planning-artifacts/prd.md#Non-Functional Requirements] — NFR5 工具扩展性
- [Source: _bmad-output/implementation-artifacts/1-2-数据模型与内存存储.md] — MemoryStore API、Channel 枚举、ToolDefinition 模型
- [Source: _bmad-output/planning-artifacts/architecture.md#Communication Patterns] — 统一错误响应格式

## Dev Agent Record

### Agent Model Used

Claude Opus 4.6 (claude-opus-4-6)

### Debug Log References

无异常，所有步骤一次通过。

### Completion Notes List

- Task 1: 在 `backend/app/agent/tools/base.py` 中定义 `BaseTool` 抽象基类，使用 ABC + `@abstractmethod` + `@property`。包含 4 个抽象成员（name、description、execute、_get_parameters）和 1 个具体方法（get_definition → ToolDefinition）
- Task 2: 在 `backend/app/mock/data.py` 中定义 `MOCK_ORDERS` 字典，包含 3 条硬编码订单记录。HT20260301001 → SUP-88901（AC #2 必须映射）。每条记录含 order_id、supplier_order_id、guest_name、hotel_name、check_in、check_out、room_type、status 共 8 个字段
- Task 3: 在 `backend/app/agent/tools/order_query.py` 中实现 `OrderQueryTool`，从 MOCK_ORDERS 查询。有效订单返回 `{"success": True, "data": {...}}`，无效订单返回 `{"error": True, "error_type": "ORDER_NOT_FOUND", "message": "订单不存在"}`
- Task 4: 在 `backend/app/agent/tools/message_send.py` 中实现 `MessageSendTool`，调用 `store.add_message` 写入消息并调用 `store.mark_channel_unread` 标记未读。支持自定义 sender，无效频道返回 INVALID_CHANNEL 错误
- Task 5: 在 `backend/app/agent/tools/refund.py` 中实现 `RefundTool`，验证订单存在后返回退款成功结果，无效订单返回 ORDER_NOT_FOUND 错误（FR24 成功/失败）
- Task 6: 在 `backend/app/mock/upstream.py` 中实现 `simulate_upstream_reply` 函数，向 upstream 频道添加供应商回复消息"已处理完成，可以办理退款"，标记频道未读，返回回复内容
- Task 7: 在 `backend/app/agent/tools/__init__.py` 中实现工具注册表。使用 `pkgutil.iter_modules` 自动导入工具模块 + `BaseTool.__subclasses__()` 发现子类 + 实例化注册。提供 `get_tool(name)`、`get_all_tools()`、`get_tool_definitions()` 三个 API
- Task 8: 在 `backend/tests/test_tools.py` 中编写 39 个单元测试覆盖全部 8 条 AC — TestBaseTool（4 tests）、TestMockData（4 tests）、TestOrderQueryTool（8 tests：含日期返回验证）、TestMessageSendTool（8 tests：含空内容验证）、TestRefundTool（6 tests：含无效订单退款失败、缺少订单号、自动填充 supplier_order_id）、TestUpstreamReply（4 tests：含无 session 抛错）、TestToolRegistry（5 tests）

## Senior Developer Review (AI)

### Review Date: 2026-02-27

### Review Outcome: Changes Requested → Fixed

### Findings (5 fixed):
- [x] [HIGH] RefundTool 始终返回成功，违反 FR24 "返回退款成功/失败" → 增加 MOCK_ORDERS 验证
- [x] [MEDIUM] MessageSendTool 接受空内容 → 增加空内容校验返回 EMPTY_CONTENT 错误
- [x] [MEDIUM] OrderQueryTool 返回不完整订单数据（缺 check_in/check_out）→ 补充返回全部字段
- [x] [MEDIUM] simulate_upstream_reply 无 session 保护 → 增加 session 检查，无 session 抛 ValueError
- [x] [MEDIUM] 工具注册表使用 __init_subclass__ 与 ABC 时序冲突 → 改回 __subclasses__() 后扫描模式

### File List

**新增文件:**
- backend/app/agent/tools/base.py
- backend/app/agent/tools/order_query.py
- backend/app/agent/tools/message_send.py
- backend/app/agent/tools/refund.py
- backend/app/mock/data.py
- backend/app/mock/upstream.py
- backend/tests/test_tools.py

**修改文件:**
- backend/app/agent/tools/__init__.py（从空文件改为工具注册表）

## Change Log

- 2026-02-27: 完成 Story 1.3 全部 8 个 Task — 定义 BaseTool 抽象基类（ABC + abstractmethod）、3 条硬编码订单数据、3 个模拟工具（OrderQueryTool、MessageSendTool、RefundTool）、上游自动回复模拟、工具注册表（pkgutil 自动发现 + subclasses 注册）。编写 32 个单元测试全部通过，加上已有 54 个测试共 86 个测试零回归。
- 2026-02-27: Code Review 修复 5 个 findings — RefundTool 增加订单验证（FR24 失败场景）、MessageSendTool 空内容校验、OrderQueryTool 返回完整订单数据（含 check_in/check_out）、simulate_upstream_reply session 保护、注册表改回后扫描模式。新增 7 个测试，总计 93 个全部通过零回归。
